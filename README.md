# Отчет по лабораторной работе: Реализация алгоритма сортировки вставками (Insertion Sort)

## 1. Общая постановка задачи

Необходимо создать компонент, реализующий интерфейс с методом сортировки массива целых чисел алгоритмом вставок (Insertion Sort). Компонент должен интегрироваться в систему Eco Framework и предоставлять единый интерфейс для работы с различными типами данных через механизм виртуальных таблиц.

## 2. Реализуемый алгоритм сортировки вставками

Алгоритм сортировки вставками основан на поэтапном построении отсортированной последовательности. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не закончится.

**Основными шагами алгоритма сортировки вставками являются:**

* Начинаем сортировку со второго элемента массива и сохраняем его в переменную key;
* Поочередно проводим сравнение key и элементов массива в отсортированной части, слева от текущего элемента;
* Если элемент из отсортированной части больше текущего элемента, он сдвигается на одну позицию вправо;
* key вставляется в образовавшееся "свободное" место;
* Переходим к следующему элементу и повторяем процесс.

## 3. Асимптотика

**Временная сложность:**

* Худший случай: O(n²) — когда массив отсортирован в обратном порядке
* Средний случай: O(n²)
* Лучший случай: O(n) — когда массив уже отсортирован

**Сложность по памяти:** O(1)

## 4. Реализация

Интерфейс компонента содержит метод для сортировки массива целых чисел:

```c
typedef struct IEcoLab1VTbl {

    /* IEcoUnknown */

    int16_t (ECOCALLMETHOD *QueryInterface)(/* in */ IEcoLab1Ptr_t me, /* in */ const UGUID* riid, /* out */ voidptr_t* ppv);
    uint32_t (ECOCALLMETHOD *AddRef)(/* in */ IEcoLab1Ptr_t me);
    uint32_t (ECOCALLMETHOD *Release)(/* in */ IEcoLab1Ptr_t me);

    /* IEcoLab1 */

    int16_t (ECOCALLMETHOD *MyFunction)(IEcoLab1Ptr_t me, int32_t* Array, uint32_t nSize);

} IEcoLab1VTbl, *IEcoLab1VTblPtr;

interface IEcoLab1 {
    struct IEcoLab1VTbl *pVTbl;
} IEcoLab1;
```

## 5. Пример работы

Алгоритм корректно обрабатывает:

* Массивы различных размеров (от 10 до 100,000 элементов)
* Уже отсортированные массивы
* Массивы, отсортированные в обратном порядке
* Массивы со случайными значениями

## 6. Сравнение с qsort из стандартной библиотеки

Тестирование проводилось на массивах размеров: 10, 100, 1,000, 10,000, 100,000 элементов. Каждый тест повторялся на одинаковых наборах случайных данных. Время измерялось с помощью функции `clock()` из библиотеки `time.h`. Результаты проверялись на корректность сортировки.

**Результаты производительности:**

<img width="750" height="186" alt="image" src="https://github.com/user-attachments/assets/310584b1-75e2-40de-a382-1f6802f4dd43" />

**Анализ результатов:**

* Малые массивы (10–100 элементов): Оба алгоритма показывают схожую производительность, время выполнения меньше точности измерения. Insertion Sort демонстрирует отличную эффективность на небольших наборах данных.
* Средние массивы (1,000 элементов): Алгоритмы работают практически одинаково (1.00x), что подтверждает эффективность Insertion Sort для массивов среднего размера.
* Крупные массивы (10,000 элементов): qsort начинает демонстрировать преимущество — он работает в 5.8 раз быстрее. Это связано с переходом квадратичной сложности O(n²) Insertion Sort против O(n log n) у qsort.
* Большие массивы (100,000 элементов): Разница становится значительной — qsort обрабатывает массив в 60.85 раз быстрее. Время выполнения Insertion Sort возрастает до 6.7 секунд, в то время как qsort справляется за 0.11 секунды.

## 7. Тестирование компонента

**Методика тестирования:**
Компонент был протестирован с использованием комплексной системы тестирования, включающей:

* Функциональные тесты: Проверка корректности сортировки на различных наборах данных
* Производительностные тесты: Сравнение времени выполнения с эталонной реализацией qsort
* Тесты на пограничные случаи: Пустые массивы, массивы из одного элемента, уже отсортированные массивы

**Результаты тестирования:**

* Корректность сортировки: 100% — все тесты пройдены успешно
* Эффективность памяти: Отсутствие утечек памяти подтверждено
* Стабильность работы: Компонент устойчиво работает при длительной эксплуатации
* Производительность: Соответствует ожидаемой асимптотической сложности O(n²)

## Выводы

Разработанный компонент с алгоритмом Insertion Sort демонстрирует отличные результаты для массивов размером до 1,000 элементов, где его производительность сравнима с qsort. Для практического применения рекомендуется использовать данный алгоритм для сортировки небольших наборов данных, где его простота реализации и малые накладные расходы дают преимущество.

При работе с массивами более 10,000 элементов целесообразно использовать более эффективные алгоритмы сортировки, такие как реализованный в стандартной библиотеке qsort.

---
